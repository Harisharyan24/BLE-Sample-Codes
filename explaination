Nice — this is a small Zephyr/BlueZ-style GATT server that defines a custom service with five characteristics (read, write, indicate, notify, write-without-response) and exposes helper functions to send notifications/indications to subscribed clients. I’ll walk through the code step-by-step, explain how the pieces interact during a BLE session, point out a few subtle details and common pitfalls, and finish with a few practical suggestions/improvements.

---

# 1) Top-level globals & UUIDs

```c
uint8_t cus_ntf_enabled = 0;
uint8_t cus_ind_enabled = 0;
```

* Two flags that track whether any connected client has enabled notifications (`cus_ntf_enabled`) or indications (`cus_ind_enabled`). They are set by the CCC (client characteristic configuration) callback functions when a client writes the CCC descriptor.
* Because these can be accessed from different contexts/threads, consider making them `volatile` or use atomic accesses / proper synchronization if your environment needs it.

UUID definitions:

```c
#define BT_UUID_CUSTOM_READ_VAL      BT_UUID_128_ENCODE(0x1111...)
// ... other UUIDs ...
static struct bt_uuid_128 custom_service_uuid = BT_UUID_INIT_128(BT_UUID_CUSTOM_SERVICE_VAL);
...
```

* Each characteristic and the service have 128-bit UUIDs. `BT_UUID_128_ENCODE` sets the 128-bit value; `BT_UUID_INIT_128(...)` builds a `struct bt_uuid_128` that the GATT macros use.

Characteristic value storage:

```c
static uint8_t read_value = 0x11;
static uint8_t write_value = 0x22;
static uint8_t indicate_value = 0x33;
static uint8_t notify_value = 0x44;
static uint8_t write_nr_value = 0x55;
```

* These are the memory locations pointed to as `user_data` for each characteristic; when a remote reads the characteristic the server returns the bytes from these variables; when written, `write_func` updates them.

---

# 2) Read callback — `read_func`

```c
static ssize_t read_func(struct bt_conn *conn, const struct bt_gatt_attr *attr,
                         void *buf, uint16_t len, uint16_t offset)
{
    const uint8_t *value = attr->user_data;
    if (offset >= sizeof(uint8_t)) {
        return 0;
    }
    if (len > sizeof(uint8_t) - offset) {
        len = sizeof(uint8_t) - offset;
    }
    return bt_gatt_attr_read(conn, attr, buf, len, offset, value, sizeof(uint8_t));
}
```

* Called by the stack when a client performs a Read Request/Read Blob.
* The code checks `offset` and clamps `len` so the read never exceeds 1 byte (since characteristic size = `sizeof(uint8_t)`).
* `bt_gatt_attr_read()` handles the actual payload packing and is the normal helper to return attribute data.
* Note: returning `0` when `offset >= size` effectively returns zero bytes (end-of-attribute). Some implementations return an ATT error for bad offset — but zero is acceptable if you want to indicate end-of-data.

---

# 3) Write callback — `write_func`

```c
static ssize_t write_func(struct bt_conn *conn, const struct bt_gatt_attr *attr,
                          const void *buf, uint16_t len, uint16_t offset, uint8_t flags)
{
    uint8_t *value = attr->user_data;
    const uint8_t *data = buf;

    if (offset != 0 || len != 1) {
        return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    }

    *value = *data;
    printk("Write characteristic: 0x%02x\n", *value);
    return len;
}
```

* Expects *exactly* one byte written at offset 0. If not, returns `BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET)` (this error code is used for both offset and wrong length in this code).
* On success it copies the single byte into the `user_data` variable and returns `len` (1).
* Suggestion: You can return a more accurate ATT error for length mismatch (e.g. `BT_ATT_ERR_INVALID_ATTRIBUTE_LEN`) if you want finer-grained error reporting.

---

# 4) CCC callbacks (Client Characteristic Configuration)

CCC descriptors are created using `BT_GATT_CCC(...)`. The CCC callback is called when a client writes the CCC descriptor to enable/disable notifications or indications.

Provided callbacks:

```c
static void indicate_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value)
{
    cus_ind_enabled = (value != 0) ? 1 : 0;
    printk("Indicate CCC changed: %s\n", cus_ind_enabled ? "enabled" : "disabled");
}

static void notify_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value)
{
    cus_ntf_enabled = (value != 0) ? 1 : 0;
    printk("Notify CCC changed: %s\n", cus_ntf_enabled ? "enabled" : "disabled");
}
```

* `value` indicates the client configuration bits (nonzero when client has enabled notify/indicate). Many stacks encode notify/indicate bits; checking `value != 0` is a reasonable shorthand for enabled/disabled.
* These callbacks set the server-side flags used by `custom_notify_all()` and `custom_indicate_all()` to decide whether to send updates.

---

# 5) The GATT service declaration — `BT_GATT_SERVICE_DEFINE(custom_svc, ...)`

This macro builds the attribute table for your custom service. The attributes are present in a fixed order. The simplified expansion (indices shown) is roughly:

0. Primary Service declaration
1. Characteristic declaration for Read (properties)
2. Read characteristic value (user\_data `&read_value`)
3. Characteristic declaration for Write
4. Write characteristic value (user\_data `&write_value`)
5. Characteristic declaration for Indicate
6. Indicate characteristic value (`&indicate_value`)
7. CCC descriptor for Indicate (callback `indicate_ccc_cfg_changed`)
8. Characteristic declaration for Notify
9. Notify characteristic value (`&notify_value`)
10. CCC descriptor for Notify (callback `notify_ccc_cfg_changed`)
11. Characteristic declaration for Write Without Response
12. Write NR characteristic value (`&write_nr_value`)

(Exact numbering can vary with compiler/stack versions, but this ordering is canonical for the way `BT_GATT_CHARACTERISTIC` and `BT_GATT_CCC` macros are used here.)

Important: when calling `bt_gatt_notify()` or `bt_gatt_indicate()` you must pass the `attr` pointer that refers to the characteristic **value attribute** — i.e., the attribute index of the characteristic's value (above: *6* for indicate value and *9* for notify value). The code uses those indices — I explain that below.

---

# 6) Notification helper — `custom_notify_all()`

```c
extern void custom_notify_all(void)
{
    if (!cus_ntf_enabled) {
        printk("Notification not sent — client has not enabled notifications\n");
        return;
    }

    notify_value++;
    bt_gatt_notify(NULL, &custom_svc.attrs[9], &notify_value, sizeof(notify_value));
    printk("Notification sent: 0x%02x\n", notify_value);
}
```

* Checks the `cus_ntf_enabled` flag — if no client enabled notifications, it skips sending.
* `bt_gatt_notify(NULL, &custom_svc.attrs[9], &notify_value, sizeof(notify_value));`

  * First param `NULL` → notify all connected peers (instead of a specific `struct bt_conn *`).
  * Second param is pointer to the attribute that represents the characteristic value (index 9 in the attribute array). This must be the **value attribute**, not the characteristic declaration or the CCC.
  * Third/ fourth params: the pointer and length of the data to be sent. The code increments the `notify_value` before sending.
* `bt_gatt_notify()` is an asynchronous fire-and-forget: it doesn't give per-connection success/failure for each remote peer.

---

# 7) Indication helper — `custom_indicate_all()`

```c
extern void custom_indicate_all(void)
{
    if (!cus_ind_enabled) {
        printk("Indication not sent — client has not enabled indications\n");
        return;
    }

    static struct bt_gatt_indicate_params ind_params;

    indicate_value++;
    ind_params.attr = &custom_svc.attrs[6];
    ind_params.func = NULL;
    ind_params.data = &indicate_value;
    ind_params.len  = sizeof(indicate_value);

    bt_gatt_indicate(NULL, &ind_params);
    printk("Indication sent: 0x%02x\n", indicate_value);
}
```

* Similar flow: check client-subscribed flag; increment value; configure `bt_gatt_indicate()` params and call it.
* `bt_gatt_indicate()` requires a `bt_gatt_indicate_params` struct. Typical fields:

  * `.attr` — attribute pointer for the value attr (index 6 here)
  * `.func` — optional callback invoked when the indication is acknowledged by the client (set to `NULL` here). If you want to know acknowledgment status, provide a function.
  * `.data`/`.len` — pointer/length of the payload
* `bt_gatt_indicate()` sends a confirmable indication (ACK required). If multiple clients are connected, the stack will handle sending to those that subscribed.
* Important: `ind_params` is declared `static` here; that keeps it valid after the function returns. If you declare it on the stack, you must ensure the buffer remains valid until the indication completes. Using `static` is acceptable but less flexible if you want per-connection bookkeeping; alternatives: allocate, or use a global/queue.

---

# 8) How a BLE client interacts with this server (sequence)

1. Client discovers your custom service by UUID.
2. Client discovers characteristics under the service and sees UUIDs and properties (READ/WRITE/INDICATE/NOTIFY).
3. Client reads the read-characteristic → server executes `read_func` and returns `read_value`.
4. Client writes to the write-characteristic → server `write_func` copies the one byte to `write_value`.
5. To receive updates:

   * Client writes to the CCC descriptor for notify (writes `0x0001`) → `notify_ccc_cfg_changed()` is called and sets `cus_ntf_enabled = 1`.
   * Or client writes to CCC for indicate (writes `0x0002`) → `indicate_ccc_cfg_changed()` sets `cus_ind_enabled = 1`.
6. Server periodically (or when events occur) calls `custom_notify_all()` / `custom_indicate_all()` to push updates to subscribed clients.

---

# 9) Attribute index mapping — why indices matter

* The `custom_svc.attrs[N]` indices must point to the **value** attribute for that characteristic. If you pass a CCC attribute or declaration to `bt_gatt_notify`/`bt_gatt_indicate`, it won’t behave correctly.
* Based on the `BT_GATT_SERVICE_DEFINE` ordering shown earlier, `attrs[6]` is the indicate *value*, `attrs[9]` is the notify *value*. The commented earlier code used different indices (`7` and `10`) — that mismatch would cause broken behavior. Your final code uses `6` and `9`, which matches the ordering in this file.

---

# 10) Small issues, improvements & best practices

* **Atomic/volatile flags:** `cus_ntf_enabled` and `cus_ind_enabled` can be modified from interrupt or different thread contexts; consider `volatile` or `atomic_t` or mutex-guarded access depending on your RTOS model.
* **Indicate params lifetime:** You use `static` `ind_params`, which ensures valid lifetime. If you ever send multiple outstanding indications concurrently you need per-indication state (or wait for the callback). Setting `.func` to a completion callback is useful to know when the client acknowledges the indication.
* **Zero/clear `ind_params` before use:** If you reuse the same struct, it’s safer to `memset(&ind_params, 0, sizeof(ind_params))` before setting fields to avoid accidental leftover fields.
* **Return codes in `read_func`/`write_func`:** You return `0` on bad offset in `read_func`. Some prefer returning `BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET)` for an explicit error. Also `write_func` uses `BT_ATT_ERR_INVALID_OFFSET` for both offset and length errors — you could return `BT_ATT_ERR_INVALID_ATTRIBUTE_LEN` for length mismatch for clearer diagnostics.
* **Characteristic size:** Right now each characteristic is a single `uint8_t`. If in future you want multi-byte values, adapt size checks and user\_data to arrays/structs.
* **Permissions & security:** Currently CCCs are created with `BT_GATT_PERM_READ | BT_GATT_PERM_WRITE` but the characteristic read/write permissions are minimal. If you need security (encryption / authentication), use the appropriate `BT_GATT_PERM_*_ENCRYPT` / `BT_GATT_PERM_*_AUTH` flags.
* **Notify/Indicate to specific connection:** You pass `NULL` to indicate/notify to broadcast to all conns. If you want to target a particular `struct bt_conn *conn`, pass it as first argument.
* **Logging:** `printk` is fine for debug; in production consider using structured logging or less verbose prints.

---

# 11) Quick checklist to debug typical problems

* If notifications/indications aren’t received:

  * Verify client actually wrote the CCC (check `printk` from your CCC callback).
  * Confirm you pass the correct attribute pointer (`attrs[9]` for notify, `attrs[6]` for indicate).
  * Ensure characteristic properties include `BT_GATT_CHRC_NOTIFY` / `BT_GATT_CHRC_INDICATE`.
* If `bt_gatt_indicate()` returns error, check that a client enabled indications (CCC) and that you passed a valid `.attr`.
* If writes fail, verify your `write_func` returns the correct ATT error codes.

---

# 12) Short, plain-language summary

* You defined a custom GATT service with five characteristics.
* `read_func` handles reads, `write_func` handles writes (1 byte).
* CCC callbacks set flags when a client subscribes to notify/indicate.
* `custom_notify_all()` and `custom_indicate_all()` increment the stored value and push it to subscribed clients using `bt_gatt_notify()` and `bt_gatt_indicate()` respectively.
* Attribute indices used to pick the characteristic value in the `custom_svc.attrs[]` array must match the order created by `BT_GATT_SERVICE_DEFINE` — you are using the correct indices in the final code (6 for indicate value, 9 for notify value).

---

If you want, I can:

* show a small modified version with suggested safety fixes (atomic flags, memset `ind_params`, better ATT error returns),
* or write a simple client test order (GATT commands) showing exact read/write/CCC writes you’d do from a phone (nRF Connect) to exercise the service.

Which of those would be most helpful next?
